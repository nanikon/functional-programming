# Лабораторная работа №1. Вариант 8, 23

## Цель работы

Освоить базовые приемы и абстракции функционального программирования: функции, поток управления и поток данных, сопоставление с образцом, рекурсия, свертка, отображение, работа с функциями как с данными, списки.

## Задание

Решить две задачи из проекта Эйлер несколькими способами:

1. монолитные реализации с использованием
    - хвостовой рекурсии;
    - рекурсии;
1. модульной реализации, где явно разделена генерация последовательности, фильтрация и свертка (должны использоваться функции fold/reduce и/или filter);
1. генерация последовательности с помощью отображения (map);
1. работа со специальным синтаксисом для циклов (где применимо);
1. работа с бесконечными списками для языков, поддерживающих ленивые коллекции или итераторы как часть языка;
1. реализация на любом удобном традиционном языке программирования для сравнения

## Выполнение

### Задача 8. Максимальное произведение

**Условие**

Наибольшее произведение четырех последовательных цифр в нижеприведенном 1000-значном числе равно 9 × 9 × 8 × 9 = 5832.

73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450

Найдите наибольшее произведение тринадцати последовательных цифр в данном числе.

**Реализации**

- рекурсия: с помощью guards я отсекаю слишком короткие массивы и определяю условие остановки, а во всех остальных случаях выбираю максимум из произведения на текущем шаге и из результата рекурсивного вызова;

```
task8Recursion xs
    | length xs < 13 = error "List must have 13 elements"
    | length xs == 13 = product xs
    | otherwise = max (product . take 13 $ xs) (task8Recursion . tail $ xs)
```

- хвостовая рекурсия: похоже на не хвостовую, но с помощью внутренней функции введен второй аргумент, который хранит в себе текущее максимальное произведение из всех предыдущих итераций; 

```
task8_TailRec = maxMult 0
  where
    maxMult n xs
        | length xs < 13 = error "List must have 13 elements"
        | length xs == 13 = max n $ product xs
        | otherwise = maxMult (max (product . take 13 $ xs) n) (tail xs)
```

- модульная реализация с помощью встроенных функций: здесь для меня открытием стало, что массив можно скоструировать с помощью функции свертки, хотя из названия кажется, что она наоборот, должна только сворачивать массив в одно значение. Но ведь этим значением может быть и новый массив. Здесь за генерацию отвечает функция groupByNFold, за фильтрацию filterShortElem и filterWithout0, свертка в результат - multiplyInnerList и встроенной функцией maximum. Итоговый результат - композиция всех этих функций;

```
groupByNFold :: Int -> [Int] -> [[Int]]
groupByNFold n xs =
    foldr
        ( \el acc ->
            foldr
                ( \curList newList ->
                    if length curList < n then (el : curList) : newList else curList : newList
                )
                [[el]]
                acc
        )
        [[head xs]]
        (tail xs)

filterShortElem :: Int -> [[Int]] -> [[Int]]
filterShortElem n = filter $ \x -> length x >= n

filterWithout0 :: [[Int]] -> [[Int]]
filterWithout0 = filter $ notElem 0

multiplyInnerList :: [[Int]] -> [Int]
multiplyInnerList = foldl (\acc el -> product el : acc) []

task8Special :: [Int] -> Int
task8Special = maximum . multiplyInnerList . filterWithout0 . filterShortElem 13 . groupByNFold 13
```

- генерация последовательности с помощью отображения: это оказалось проще и компактнее, чем использовать для этого свертку. Замена произошла при генерации и при преобразовании внутренних массивов в произведения их элементов;

```
groupByNMap :: Int -> [Int] -> [[Int]]
groupByNMap n list
    | n > length list = error "List must have more or equal n elements"
    | otherwise = map (\x -> take n . drop x $ list) [0 .. length list - n]

task8Map :: [Int] -> Int
task8Map = maximum . map product . groupByNMap 13
```

- специального синтаксиса для циклов в haskell нет (если только не притянуть for у монад), так что этот этап я пропустила;

- использование ленивых итераторов. Также здесь попробовала синтаксис генераторов списков;

```
task8Iterate list = maximum (take (length list - 13) [product . take 13 . drop x $ list | x <- [0 ..]])
```

- Реализация на привычном языке программирования: для этой цели я выбрала python. По сути алгоритм аналогичен хвостовой рекурсии, переложенной в цикл.

```
def task8(input):
    if (len(input)) < 13:
        raise ValueException("List must have 13 elements minimum")
    max_product = 0
    for i in range(0,len(input)-12):
        cur_product = input[i]
        for j in range(1,13):
            cur_product *= input[i+j]
        if cur_product > max_product:
            max_product = cur_product
    return max_product
```

### Задача 23. Сумма неизбыточных чисел

**Условие**

Совершенным числом называется число, у которого сумма его делителей равна самому числу. Например, сумма делителей числа 28 равна 1 + 2 + 4 + 7 + 14 = 28, что означает, что число 28 является совершенным числом.

Число n называется недостаточным, если сумма его делителей меньше n, и называется избыточным, если сумма его делителей больше n.

Так как число 12 является наименьшим избыточным числом (1 + 2 + 3 + 4 + 6 = 16), наименьшее число, которое может быть записано как сумма двух избыточных чисел, равно 24. Используя математический анализ, можно показать, что все целые числа больше 28123 могут быть записаны как сумма двух избыточных чисел. Эта граница не может быть уменьшена дальнейшим анализом, даже несмотря на то, что наибольшее число, которое не может быть записано как сумма двух избыточных чисел, меньше этой границы.

Найдите сумму всех положительных чисел, которые не могут быть записаны как сумма двух избыточных чисел.

**Реализации**

- Рекурсия: эти реализации я пропустила, так как, на мой взгляд, эту задача достаточно сложно решить без встроенных функций;

- модульная реализация с помощью встроенных функций: генерация - просто объявление списка, фильтрация с помощью функции isSumAb (у которой внутри есть отдельная генерация сумм делителей, фильтрация избыточных чисел и свертка с помощью any), свертка встроенной функцией sum;

```
divisionSum :: Int -> Int
divisionSum n =
    foldr
        ( \x acc ->
            let t = n `div` x
             in if n `mod` x == 0
                    then
                        if x == t
                            then acc + x
                            else acc + x + t
                    else acc
        )
        1
        [2 .. intSqrt n]

isAbundant :: Int -> Bool
isAbundant = memo (\n -> divisionSum n > n)

isSumAb :: Int -> Bool
isSumAb n = any (\k -> isAbundant (n - k)) (filter isAbundant [1 .. n - 1])

task23Spec :: Int -> Int
task23Spec limit = sum $ filter (not . isSumAb) [1 .. limit]
```

- генерация последовательности с помощью отображения: поменяла только генерацию суммы множителей на использование map, а так реализация похожа на предыдущую;

```
divisionsByMap :: Int -> [Int]
divisionsByMap n =
    1
        : map
            ( \x ->
                let t = n `div` x
                 in if n `mod` x == 0
                        then
                            if x == t
                                then x
                                else x + t
                        else 0
            )
            [2 .. intSqrt n]
```

- специального синтаксиса для циклов нет, так что эту реализацию я опять пропустила;

- использование ленивых итераторов. Также во многом аналогично варианту со свертками, только вместо верхних границ списков используется функция takeWhile с условием;

```
abundantNums :: [Int]
abundantNums = filter isAbundant [1 ..]

isSumTwoAb :: Int -> Bool
isSumTwoAb n = any (\k -> isAbundant (n - k)) (takeWhile (< n) abundantNums)

task23Lazy :: Int -> Int
task23Lazy limit = sum $ filter (not . isSumTwoAb) (takeWhile (<= limit) [1 ..])
```

- Реализация на привычном языке программирования: для этой цели я выбрала python. Активно используется возможность изменения данных, так что в точности этот алгоритм соотнести с какой-либо функциональной реализацией не получается.

```
def task23(input):
    limit = input + 1
    divisors_sum = [0] * limit
    for i in range(1, limit):
        for j in range(i * 2, limit, i):
            divisors_sum[j] += i
    ab_nums = [i for (i, x) in enumerate(divisors_sum) if x > i]

    sums = [False] * limit
    for i in ab_nums:
        for j in ab_nums:
            if i + j < limit:
                sums[i + j] = True
            else:
                break
    ans = sum(i for (i, x) in enumerate(sums) if not x)
    return ans
```

## Выводы

В ходе выполнения лабораторной работы я познакомилась с парадигмой функционального программирования. Самым сложным для меня в ней оказалась неизменяемость данных, так как для оптимизации я привыкла в одном цикле делать несколько задач параллельно (например - решение 23-ей задачин на языке python). Также вначале я часто путалась в типах, так что хорошо, что выбранный язык имеет статическую типизацию и все несоответствия мог показать на этапе компиляции.
